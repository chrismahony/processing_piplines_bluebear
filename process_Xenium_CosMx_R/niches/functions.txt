cellgeoms_with_area_centroid_slow <- function(segfile) {
  # Step 1: Calculate transcripts per cell
  transcriptspercell <- furrr::future_map_dfr(
    .x = unique(segfile$cell),
    .f = ~ data.frame(
      cell = .x,
      num_transcripts = sum(segfile$cell == .x)
    ),
    .options = furrr_options(seed = TRUE)
  )

  # Step 2: Filter cells with more than 5 transcripts
  cellidx <- transcriptspercell$cell[transcriptspercell$num_transcripts > 5]

  # Step 3: Calculate geometry for each cell using triangulation
  segfile.new <- furrr::future_map_dfr(
    .x = cellidx,
    .f = function(.x) {
      res <- st_as_sf(segfile[segfile$cell == .x, c('x', 'y')], coords = c('x', 'y')) %>%
        st_union() %>%  # st_union is needed here
        ct_triangulate()
      resdf <- data.frame(cell = .x, geometry = res)
      return(resdf)
    },
    .options = furrr_options(seed = TRUE)
  )

  # Step 4: Finalize cell geometries by merging geometries for each cell
  cellgeoms_final <- segfile.new$geometry %>%
    furrr::future_map(purrr::reduce, st_union, .options = furrr_options(seed = TRUE)) %>%
    st_sfc() %>%
    as.data.frame()

  # Step 5: Add transcript count information to the geometry data
  cellgeoms_final <- cellgeoms_final %>%
    cbind(transcriptspercell[transcriptspercell$cell %in% cellidx, ])

  # Step 6: Calculate area and centroids for each geometry
  # Calculate the area of each geometry
  cellgeoms_final$area <- st_area(cellgeoms_final$geometry)

  # Calculate the centroid of each geometry
  centroids <- st_centroid(cellgeoms_final$geometry)

  # Extract X and Y coordinates of the centroid
  centroid_coords <- st_coordinates(centroids)
  cellgeoms_final$centroid_x <- centroid_coords[, 1]
  cellgeoms_final$centroid_y <- centroid_coords[, 2]

  # Return the final data frame with area and centroid columns
  return(cellgeoms_final)
}



cellgeoms_with_area_centroid_fast <- function(segfile) {
  # Step 1: Calculate transcripts per cell
  transcriptspercell <- furrr::future_map_dfr(
    .x = unique(segfile$cell),
    .f = ~ data.frame(
      cell = .x,
      num_transcripts = sum(segfile$cell == .x)
    ),
    .options = furrr_options(seed = TRUE)
  )

  # Step 2: Filter cells with more than 5 transcripts
  cellidx <- transcriptspercell$cell[transcriptspercell$num_transcripts > 5]

  # Step 3: Calculate and union geometry for each cell
  segfile.new <- furrr::future_map_dfr(
    .x = cellidx,
    .f = function(.x) {
      cell_data <- segfile[segfile$cell == .x, c('x', 'y')]
      # Create an sf object and triangulate
      triangles <- st_as_sf(cell_data, coords = c('x', 'y')) %>%
        st_combine() %>%
        ct_triangulate() %>%
        st_union()  # Combine triangles into one geometry per cell
      data.frame(cell = .x, geometry = st_geometry(triangles))
    },
    .options = furrr_options(seed = TRUE)
  )

  # Step 4: Add transcript count information to the geometry data
  cellgeoms_final <- dplyr::left_join(segfile.new, transcriptspercell, by = "cell")

  # Step 5: Calculate area and centroids for each geometry
  cellgeoms_final <- cellgeoms_final %>%
    mutate(
      area = st_area(geometry),
      centroid = st_centroid(geometry)
    )

  # Extract X and Y coordinates of the centroid
  centroid_coords <- st_coordinates(cellgeoms_final$centroid)
  cellgeoms_final$centroid_x <- centroid_coords[, 1]
  cellgeoms_final$centroid_y <- centroid_coords[, 2]

  # Remove the temporary centroid column
  cellgeoms_final$centroid <- NULL

  # Return the final data frame with area and centroid columns
  return(cellgeoms_final)
}


make_count_mtx <- function(genes, cells, remove_bg = TRUE) {
    if (remove_bg) {
        idx <- cells != 0  # Logical indexing is faster than `which`
        genes <- genes[idx]
        cells <- cells[idx]
    }

    # Retrieve unique levels once for efficiency
    unique_genes <- unique(genes)
    unique_cells <- unique(cells)
    
    # Map genes and cells to integer indices
    gene_idx <- match(genes, unique_genes)
    cell_idx <- match(cells, unique_cells)
    
    # Create sparse matrix
    counts <- Matrix::sparseMatrix(
        i = gene_idx, 
        j = cell_idx, 
        x = rep(1, length(gene_idx)),  # Each entry is 1
        dims = c(length(unique_genes), length(unique_cells))
    )
    
    # Set row and column names
    rownames(counts) <- unique_genes
    colnames(counts) <- unique_cells
    
    return(counts)
}

process_seurat_data <- function(data, combined_df, num_datasets = 3) {
  # Create empty lists to store counts and Seurat objects
  counts <- list()
  seurats <- list()

  # Loop through each dataset to create count matrices and Seurat objects
  for (i in 1:num_datasets) {
    counts[[i]] <- make_count_mtx(genes = data[[i]]$gene, data[[i]]$cell_id_new)
    seurats[[i]] <- CreateSeuratObject(counts = counts[[i]], project = unique(data[[i]]$donor_FOV))
  }

  # Merge all Seurat objects
  all_merged <- merge(x = seurats[[1]], y = seurats[2:length(seurats)])

  # Add cell area metadata
  cell_area_vector <- setNames(combined_df$area, combined_df$cell)
  all_merged <- AddMetaData(all_merged, metadata = cell_area_vector, col.name = "cell_area")

  # Remove cells with NA in cell_area
  na_cells <- all_merged@meta.data[is.na(all_merged@meta.data$cell_area), ]
  all_merged <- all_merged[, !colnames(all_merged) %in% rownames(na_cells)]

  # Subset based on feature and count thresholds
  all_merged <- subset(all_merged, subset = nFeature_RNA > round(median(all_merged$nFeature_RNA)/2) &
                         nCount_RNA > round(median(all_merged$nCount_RNA)/2) &
                         cell_area > round(median(all_merged$cell_area)/4))

  # Normalize and scale data, find variable features, run PCA and UMAP
  all_merged <- all_merged %>% 
    NormalizeData(scale.factor = median(all_merged$nCount_RNA)) %>% 
    ScaleData() %>% 
    FindVariableFeatures() %>% 
    RunPCA() %>% 
    RunUMAP(dims = 1:40) %>% 
    FindNeighbors(dims=1:40) %>% 
    FindClusters(res=c(0.01, 0.05, 0.1, 0.2))

  # Plot UMAP
  DimPlot(all_merged, raster = FALSE) + NoLegend()

  return(all_merged)
}





pts_to_voronoi = function(x, y, eps=0, bbox=NULL) {
    if (is.null(bbox)) {
        bbox = st_rectangle(min(x) - eps, max(x) + eps, min(y) - eps, max(y) + eps)        
    }
    tiles = cbind(x, y) %>% st_multipoint() %>% st_voronoi(bbox) %>% st_collection_extract() 
    pts = st_as_sf(data.frame(x, y), coords = c('x', 'y'))
    tiles = tiles[unlist(st_intersects(pts, tiles))] ## put them in order: THIS MUST BE OPTIMIZED AT SOME POINT 
    tiles = st_crop(tiles, bbox)
    return(tiles)
}



alpha_shape_cells<-function(cells_voronoi){
    # this functions takes the OP of Voronoi tessallation and alpha shapes the cells the edge cells
    message(" alpha shape cells")
    cells_voronoi<-cells_voronoi %>% 
        dplyr::mutate(
            polygon_centroid = st_centroid(polygon),
            polygon_area = st_area(polygon),
            cell_voronoi_dist = st_distance(cell_centroid, polygon_centroid, by_element = TRUE)
        ) %>% 
        dplyr::select(tileID, cellID, everything()) %>% st_sf()
    # create a 15µm buffer from the cell centroid of each cell in the whole tissue
    buffer_cells<-cells_voronoi %>% st_set_geometry("cell_centroid") %>% 
        dplyr::select(cell_centroid) %>% 
        st_buffer(15) %>% 
        st_union  
    # every cell is an intersection b/w itself and the buffer - this way, the "edge cells" will become a circular shape 
    cells_voronoi_final<-cells_voronoi %>% st_set_geometry("polygon") %>% 
        st_intersection(buffer_cells)
    # find the "weird cells" - because we want to change the shapes of edge cells and the 
        ##cells whose cell centroid and voronoi centroid are > 7µm apart
    boundary_tissue<-cells_voronoi_final %>%   
        st_set_geometry("polygon") %>% 
        st_union() %>% 
        st_boundary %>% 
        as.data.frame %>% 
        dplyr::mutate(boundary = TRUE) %>% st_sf
    # correct the shapes of "edge cells" and the cells whose cell centroid and voronoi centroid are > 7µm apart
    cells_edge_cases<-st_join(
        cells_voronoi_final, 
        boundary_tissue,
        join = st_touches
    ) %>% 
        subset(boundary == TRUE) %>% 
        bind_rows(cells_voronoi_final %>% subset(cell_voronoi_dist > 7)) %>% # also change cells whose vornoi shapes are very different from the cell shapes    
        dplyr::select(-boundary) %>% 
        distinct
    # Voronoi shapes are frozen. Don't change shapes beyond this.
    cells_voronoi_final<-cells_voronoi_final %>% 
        subset(!cellID %in% cells_edge_cases$cellID) %>% 
        bind_rows(cells_edge_cases) 
    # re-calculate properties of the new Voronoi polygons
    cells_voronoi_final<-cells_voronoi_final %>%
        dplyr::mutate(
            polygon_centroid = st_centroid(polygon),
            polygon_area = st_area(polygon),
            cell_voronoi_dist = st_distance(cell_centroid, polygon_centroid, by_element = TRUE)
        ) %>% 
        dplyr::select(tileID, cellID, everything()) 
    return(cells_voronoi_final)
    }
    
pts_to_voronoi <- function(x, y, eps = 0, bbox = NULL) {
    if (is.null(bbox)) {
        bbox <- st_rectangle(min(x) - eps, max(x) + eps, min(y) - eps, max(y) + eps)
    }
    
    # Combine points and compute Voronoi diagram directly
    pts <- st_as_sf(data.frame(x, y), coords = c('x', 'y'))
    voronoi_tiles <- st_voronoi(st_union(pts), bbox) %>% st_collection_extract()

    # Intersect and crop in one step
    voronoi_tiles <- st_intersection(voronoi_tiles, bbox)
    
    return(voronoi_tiles)
}

alpha_shape_cells <- function(cells_voronoi) {
    message("Alpha shaping cells")
    
    # Pre-compute properties for cells
    cells_voronoi <- cells_voronoi %>%
        mutate(
            polygon_centroid = st_centroid(polygon),
            polygon_area = st_area(polygon),
            cell_voronoi_dist = st_distance(cell_centroid, polygon_centroid, by_element = TRUE)
        ) %>% 
        st_sf()
    
    # Buffer and union directly for all cells
    buffer_cells <- st_union(st_buffer(st_geometry(cells_voronoi$cell_centroid), 15))
    
    # Adjust Voronoi polygons by intersection
    cells_voronoi <- cells_voronoi %>% 
        mutate(polygon = st_intersection(st_geometry(polygon), buffer_cells))
    
    # Identify boundary cells
    boundary_tissue <- st_union(cells_voronoi$polygon) %>% st_boundary()
    
    # Handle edge cases in one go
    cells_edge_cases <- cells_voronoi %>%
        mutate(
            is_boundary = st_touches(st_geometry(polygon), boundary_tissue, sparse = FALSE),
            is_outlier = cell_voronoi_dist > 7
        ) %>%
        filter(is_boundary | is_outlier) %>%
        distinct(cellID, .keep_all = TRUE) 
    
    # Update final Voronoi shapes
    cells_voronoi <- cells_voronoi %>%
        filter(!cellID %in% cells_edge_cases$cellID) %>%
        bind_rows(cells_edge_cases) %>%
        mutate(
            polygon_centroid = st_centroid(polygon),
            polygon_area = st_area(polygon),
            cell_voronoi_dist = st_distance(cell_centroid, polygon_centroid, by_element = TRUE)
        )
    
    return(cells_voronoi)
}    


grid_glass<-function(glass_region_input, txfile_input, cellgeoms_input, by_counts = TRUE, ncounts = 100){ 

    if (!by_counts){
        median_voronoi_size<-cellgeoms_input %>% 
            with(sqrt(median(polygon_area)))  
        glass_gridded<-st_make_grid(
            st_rectangle(min(txfile_input$x), max(txfile_input$x), min(txfile_input$y), max(txfile_input$y)), 
            cellsize = median_voronoi_size, 
            square = TRUE
        ) %>% 
        st_intersection(st_sf(glass_region_input)) %>% 
        st_cast("MULTIPOLYGON") %>% 
        st_cast("POLYGON") %>% 
        dplyr::mutate(
            tileID = seq(1, nrow(.)),
            tileID = paste(paste0("G", tileID), txfile_input$SampleFOV[1], sep = "_")
        )
    } else { #check if there are acceptable #tx in the bg. If there are then proceed with tiling  
        txfile_glass<-txfile_input %>% st_sf %>% 
            st_join(st_sf(glass_region_input), st_intersects) %>% 
            subset(region %in% "glass")
        # if there are no tx in the glass region, don't tile it
        if (nrow(txfile_glass) < ncounts/2) {
            glass_gridded<-NULL
            } else {
            system.time({glass_gridded<-spatula::split_tx(txfile_glass, ncounts, 1e3)})
            glass_gridded<-glass_gridded %>% 
                purrr::map(~ .x$bbox_geom %>% st_sfc %>% as.data.frame) %>%
                rbindlist    
            }     
    }   
    if (!is.null(glass_gridded)){
        glass_gridded<-glass_gridded %>%
            st_sf %>% 
            st_intersection(st_sf(glass_region_input)) %>% 
            st_cast("MULTIPOLYGON") %>% 
            st_cast("POLYGON") %>% 
            dplyr::mutate(
                tileID = seq(1, nrow(.)),
                tileID = paste(paste0("G", tileID), txfile_input$SampleFOV[1], sep = "_")
            )
    }
    return(glass_gridded)

}

diffuse_adjmat <- function(metadata, gcmat, lambda = 0.1, k = 1, pxsize = 1, 
                           verbose = TRUE, cut_connections = FALSE, prune_connections = TRUE, 
                           prune_communities = TRUE, dist_threshold_cells = 50, community_size_thresh = 4) {
  message("Diffusing and cleaning up")
  
  metadata <- metadata %>% subset(tileID %in% colnames(gcmat)) %>% st_sf()
  gcmat <- gcmat[, as.character(metadata$tileID)]
  
  voronoi_coords_centroid <- metadata %>% st_sf() %>% st_set_geometry("polygon_centroid") %>% 
    st_coordinates("polygon_centroid") %>% as.data.frame() %>% 
    dplyr::select(X, Y) %>% as.matrix()
  
  adjoutput <- getSpatialNeighbors_obtuse_fix(voronoi_coords_centroid, dist_thresh = Inf, return_weights = TRUE, fix_obtuse = FALSE)
  spatial_neighbors <- adjoutput$adjmat
  
  if (cut_connections) {
    cells.bg <- metadata %>% subset(region %in% "glass") %>% with(tileID)
    if (length(cells.bg) > 0) {
      cellids.bg <- which(colnames(gcmat) %in% cells.bg)
      cellids.fg <- which(!colnames(gcmat) %in% cells.bg)
      spatial_neighbors[cellids.fg, cellids.bg] <- 0
      spatial_neighbors[cellids.bg, cellids.fg] <- 0
    }
  }
  
  # within the tissue region
  if (prune_connections) {
    cells.fg <- metadata %>% subset(region %in% "tissue") %>% with(tileID)
    cellids.fg <- which(colnames(gcmat) %in% cells.fg)
    adjmat.fg <- spatial_neighbors[cellids.fg, cellids.fg]
    cellids.far <- which(adjmat.fg > dist_threshold_cells)
    adjmat.fg[cellids.far] <- 0
    spatial_neighbors[cellids.fg, cellids.fg] <- adjmat.fg   
  }
  
  message("here")
  
  if (prune_communities) {
    cells.fg <- metadata %>% subset(region %in% "tissue") %>% with(tileID)
    cellids.fg <- which(colnames(gcmat) %in% cells.fg)
    cells.fg <- colnames(gcmat)[cellids.fg]
    adjmat.fg <- spatial_neighbors[cellids.fg, cellids.fg]
    
    graph_adj1 <- igraph::graph_from_adjacency_matrix(adjmat.fg, mode = "undirected")
    comp_graph <- components(graph_adj1)
    comp.delete <- which(comp_graph$csize < community_size_thresh)
    cellids.delete <- which(comp_graph$membership %in% comp.delete)
    
    if (length(cellids.delete) > 0) {
      cells.delete <- cells.fg[cellids.delete]
      adjmat.fg[cellids.delete, ] <- 0
      adjmat.fg[, cellids.delete] <- 0
      spatial_neighbors[cellids.fg, cellids.fg] <- adjmat.fg
      
      cellids.delete.global <- which(colnames(gcmat) %in% cells.delete)
      spatial_neighbors <- spatial_neighbors[-cellids.delete.global, -cellids.delete.global]
      gcmat <- gcmat[, !colnames(gcmat) %in% cells.delete]
      
      metadata_small <- metadata %>% subset(!tileID %in% colnames(gcmat))
      metadata <- metadata %>% subset(tileID %in% colnames(gcmat))
      gcmat <- gcmat[, as.character(metadata$tileID)]
    } else {
      metadata_small <- NULL
    }
  } else {
    metadata_small <- NULL
  }
  
  if (verbose) {
    message("  Unique diagonal elements in the adjacency matrix: ", unique(diag(spatial_neighbors)))
  }
  
  A <- spatial_neighbors 
  A[A > 0] <- 1 # Ensure A remains dgCMatrix
  A <- Diagonal(n = nrow(A)) + (lambda * A)
  A <- Diagonal(x = 1 / rowSums(A)) %*% A
  M <- A
  Mlist <- list()
  Mlist[[1]] <- A
  
  for (i in seq_len(k - 1)) {
    M <- A %*% M
    Mlist[[i + 1]] <- M
  }
  
  message(nrow(Mlist[[1]]))
  message(ncol(Mlist[[1]]))
  message(nrow(gcmat))
  message(ncol(gcmat))
  
  # Ensure dimensions match before matrix multiplication
  if (ncol(gcmat) != nrow(Mlist[[k - 1]])) {
    stop("Dimension mismatch between gcmat and Mlist[[k - 1]]")
  }
  
  collapsed_counts <- gcmat %*% t(Mlist[[k - 1]])
  colnames(collapsed_counts) <- colnames(gcmat)
  
  return(list(neighbors = spatial_neighbors, neighbors_collapsed = Mlist, 
              k_input = k, counts = collapsed_counts, metadata = metadata, metadata_small = metadata_small, counts_raw = gcmat))
}


getSpatialNeighbors_obtuse_fix<-function(coords, fix_obtuse = TRUE, 
    dist_thresh = Inf, return_weights = FALSE) 
{
    triplets <- geometry::delaunayn(coords)
    if (fix_obtuse){
        triplet_idx <- NULL
        angles_all<-NULL
        lengths_all<-NULL
        for (i in 1:nrow(triplets)) {
            triangle <- triplets[i, ]
            vertices_triangle <- coords[triangle, ]
            a <- vertices_triangle[1, ]
            b <- vertices_triangle[2, ]
            c <- vertices_triangle[3, ]
            ab <- b - a
            bc <- c - b
            ca <- a - c
            length_edge1<-sqrt(sum(ab^2))
            length_edge2<-sqrt(sum(bc^2))
            length_edge3<-sqrt(sum(ca^2))
            dot_product <- sum(-ab * bc)
            norm_product <- sqrt(sum(ab^2)) * sqrt(sum(bc^2)) # not doing -ab because this is squared anyway
            angle12 <- acos(pmax(pmin(dot_product/norm_product, 1.0), -1.0))
            angle12 <- angle12 * (180/pi)
            dot_product <- sum(ca * -bc)
            norm_product <- sqrt(sum(ca^2)) * sqrt(sum(bc^2))
            angle23 <- acos(pmax(pmin(dot_product/norm_product, 1.0), -1.0))
            angle23 <- angle23 * (180/pi)
            dot_product <- sum(-ca * ab)
            norm_product <- sqrt(sum(ca^2)) * sqrt(sum(ab^2))
            angle31 <- acos(pmax(pmin(dot_product/norm_product, 1.0), -1.0)) # making sure values are bounded b/w [-1, 1]
            angle31 <- angle31 * (180/pi)
            angles_all <- rbind(angles_all, c(angle12, angle23, angle31, triangle)) # contains angles and the point idx of triangles
            lengths_all <- rbind(lengths_all, c(length_edge1, length_edge2, length_edge3, triangle)) # contains lengths and the point idx of triangles

            if (any(angles_all > 150)) {
                triplet_idx <- c(triplet_idx, i)
            }
        }
        message("Before fixing for angles: ", print(dim(triplets)))
        triplets <- triplets[-triplet_idx, ]
        message("After fixing for angles: ", print(dim(triplets)))
    } else {
        lengths_all<-NULL
        angles_all<-NULL
    }
    pairs <- spatula:::triplets_to_pairs(triplets)
    pairs <- unique(pairs)
    dists <- sqrt(rowSums((coords[pairs[, 1], ] - coords[pairs[, 2], ])^2))
    # apply the distance threshold 
    if (is.infinite(dist_thresh)) {
        idx_keep <- seq_len(nrow(pairs))
    }
    else {
        idx_keep <- which(dists < dist_thresh)
    }
    if (return_weights == FALSE) {
        dists <- rep(1, nrow(pairs))
    }
    adjmat <- Matrix::sparseMatrix(i = pairs[idx_keep, 
        1], j = pairs[idx_keep, 2], x = dists[idx_keep], dims = c(nrow(coords), 
        nrow(coords)))
    
    return(list(adjmat = adjmat, lengths = lengths_all, angles = angles_all))
}



dimred_and_cluster<-function (clusterobj, do_harmony = FALSE, ...) 
{
  input_var<-list(...)
  if( is.null( input_var[["sigma"]] ) ) message("You did not specify sigma for Harmony") 
  else sigma_harmony<-input_var[["sigma"]]
  
  if( is.null( input_var[["theta"]] ) ) message("You did not specify theta for Harmony")
  else theta_harmony<-input_var[["theta"]]
  if( is.null( input_var[["vars_use"]] ) ) message("You did not specify batch var for Harmony")
  else batch_harmony<-input_var[["vars_use"]]
  wts <- clusterobj$metadata %>% with(table(as.factor(region))) %>% 
    prop.table %>% as.data.frame %>% mutate(region = Var1) %>% 
    mutate(wts = 1/Freq) %>% mutate(region = as.character(region))
  clusterobj$metadata <- clusterobj$metadata %>% left_join(wts %>% 
                                                             dplyr::select(region, wts), by = "region")
  head(clusterobj$metadata)
  if (do_harmony) {
    norm_value <- median(colSums(clusterobj$counts))
    objH <- QC_harmony_pipeline(clusterobj, ngenes_threshold = 1, 
                                ncounts_threshold = 1, norm_value, ...)
    objH$sigma_harmony <- sigma_harmony
    objH$vars_use <- batch_harmony
    objH$theta_harmony <- theta_harmony
    clusterobj <- objH
  }
  else {
    set.seed(9)
    # diag(clusterobj$umap$fgraph) <- 1
    print("Clustering on SNN")
    system.time({
      clusterobj$umap$clusters <- RunModularityClustering(clusterobj$umap$fgraph, 
                                                          resolution = c(0.2, 0.5, 0.7, 1), n_cores = 10, 
                                                          print.output = FALSE)
    })
  }
  return(clusterobj)
}



QC_harmony_pipeline <- function(data_obj, ngenes_threshold, ncounts_threshold, normval, 
         wts = NULL, do_QC = TRUE, do_pca = TRUE, do_umap_before = TRUE, do_umap_after = TRUE, 
         do_cluster_before = FALSE, do_cluster_after = TRUE, resolution_clustering = 1.5, 
         return_object = FALSE, verbose = TRUE, ...) {
  set.seed(9)
  obj <- list()
  
  if (do_QC) {
    if (verbose) message("Step1: QC")
    obj$counts <- QC_gcmat(data_obj$counts, ngenes_threshold, ncounts_threshold)
    obj$metadata <- data_obj$metadata %>% subset(cellID %in% colnames(obj$counts))
  } else {
    obj$counts <- data_obj$counts
    obj$metadata <- data_obj$metadata
  }
  obj$harmony_normval <- normval
  obj$harmony_ngenes_threshold <- ngenes_threshold
  obj$harmony_ncounts_threshold <- ncounts_threshold
  
  if (do_pca) {
    if (verbose) message("Step2: Normalize and PCA")
    obj$logcpx <- singlecellmethods::normalizeData(obj$counts, normval, method = "log")
    
    if (is.null(wts)) {
      obj$pca_res <- singlecellmethods::weighted_pca(obj$logcpx, weights = rep(1, dim(obj$counts)[2]), npc = 20, do_corr = FALSE)
    } else {
      obj$pca_res <- singlecellmethods::weighted_pca(obj$logcpx, weights = obj$metadata[[wts]], npc = 20, do_corr = FALSE)
    }
  }
  
  if (do_umap_before) {
    if (verbose) message("Running UMAP before Harmony")
    obj$umap <- uwot::umap(obj$pca_res$embeddings, min_dist = 0.3, spread = 1, ret_extra = "fgraph", fast_sgd = TRUE)
  }
  
  if (do_cluster_before) {
    if (verbose) message("Clustering before Harmony")
    set.seed(9)
    system.time({
      resolutions <- ifelse(length(resolution_clustering) > 1, resolution_clustering, list(resolution_clustering))
      obj$umap$clusters <- lapply(resolutions, function(res) {
        RunModularityClustering(obj$umap$fgraph, resolution = res, print.output = FALSE)
      })
    })
  }
  
  if (return_object) {
    if (verbose) message("Running Harmony")
    
    # Check levels of factor variables in metadata
    factors_with_few_levels <- sapply(obj$metadata, function(x) is.factor(x) && length(levels(x)) < 2)
    if (any(factors_with_few_levels)) {
      warning("Some factors in metadata have fewer than 2 levels. Harmony requires at least 2 levels for contrasts.")
      factors_to_check <- names(factors_with_few_levels)[factors_with_few_levels]
      message("Factors with fewer than 2 levels: ", paste(factors_to_check, collapse = ", "))
      # Handle or remove factors with fewer than 2 levels
      obj$metadata <- obj$metadata[ , !factors_with_few_levels]
    }
    
    Hobj <- harmony::HarmonyMatrix(obj$pca_res$embeddings[, 1:20], obj$metadata, do_pca = FALSE, verbose = TRUE, plot_convergence = TRUE, epsilon.cluster = -Inf, epsilon.harmony = -Inf, return_object = TRUE, ...)
    obj$H <- t(as.matrix(Hobj$Z_corr))
    rownames(obj$H) <- rownames(obj$pca_res$embeddings[, 1:20])
    colnames(obj$H) <- colnames(obj$pca_res$embeddings[, 1:20])
    obj$Hobj <- list(kmeans_rounds = Hobj$kmeans_rounds, objective_kmeans = Hobj$objective_kmeans)
  } else {
    if (verbose) message("Running Harmony")
    
    # Check levels of factor variables in metadata
    factors_with_few_levels <- sapply(obj$metadata, function(x) is.factor(x) && length(levels(x)) < 2)
    if (any(factors_with_few_levels)) {
      warning("Some factors in metadata have fewer than 2 levels. Harmony requires at least 2 levels for contrasts.")
      factors_to_check <- names(factors_with_few_levels)[factors_with_few_levels]
      message("Factors with fewer than 2 levels: ", paste(factors_to_check, collapse = ", "))
      # Handle or remove factors with fewer than 2 levels
      obj$metadata <- obj$metadata[ , !factors_with_few_levels]
    }
    
    obj$H <- harmony::HarmonyMatrix(obj$pca_res$embeddings[, 1:20], obj$metadata, do_pca = FALSE, verbose = TRUE, plot_convergence = TRUE, epsilon.cluster = -Inf, epsilon.harmony = -Inf, ...)
  }
  
  if (do_umap_after) {
    if (verbose) message("Running UMAP after Harmony")
    set.seed(9)
    obj$Humap <- uwot::umap(obj$H, min_dist = 0.3, spread = 1, ret_extra = "fgraph", fast_sgd = TRUE)
  }
  
  if (do_cluster_after) {
    if (verbose) message("Clustering after Harmony")
    set.seed(9)
    system.time({
      resolutions <- ifelse(length(resolution_clustering) > 1, resolution_clustering, list(resolution_clustering))
      obj$Humap$clusters <- lapply(resolutions, function(res) {
        RunModularityClustering(obj$Humap$fgraph, resolution = res, print.output = FALSE)
      })
    })
  }
  
  return(obj)
}


QC_gcmat<-function(gcmat, gene_thresh, count_thresh){
    ngenes<-colSums(gcmat > 0)
    ncounts<-colSums(gcmat)
    gcmat<-gcmat[, ngenes >= gene_thresh & ncounts >= count_thresh]
}



RunModularityClustering <- function(
    SNN = matrix(),
    modularity = 1,
    resolution = 0.8,
    algorithm = 1,
    n.start = 10,
    n.iter = 10,
    random.seed = 0,
    print.output = TRUE,
    temp.file.location = NULL,
    edge.file.name = NULL
) {
  edge_file <- edge.file.name %||% ''
  clusters <- RunModularityClusteringCpp(
    SNN,
    modularity,
    resolution,
    algorithm,
    n.start,
    n.iter,
    random.seed,
    print.output,
    edge_file
  )
  return(clusters)
}

RunModularityClusteringCpp <- function(SNN, modularityFunction, resolution, algorithm, nRandomStarts, nIterations, randomSeed, printOutput, edgefilename) {
  .Call('_Seurat_RunModularityClusteringCpp', PACKAGE = 'Seurat', SNN, modularityFunction, resolution, algorithm, nRandomStarts, nIterations, randomSeed, printOutput, edgefilename)
}

dimred_and_cluster<-function (clusterobj, do_harmony = FALSE, ...) 
{
  input_var<-list(...)
  if( is.null( input_var[["sigma"]] ) ) message("You did not specify sigma for Harmony") 
  else sigma_harmony<-input_var[["sigma"]]
  
  if( is.null( input_var[["theta"]] ) ) message("You did not specify theta for Harmony")
  else theta_harmony<-input_var[["theta"]]
  if( is.null( input_var[["vars_use"]] ) ) message("You did not specify batch var for Harmony")
  else batch_harmony<-input_var[["vars_use"]]
  wts <- clusterobj$metadata %>% with(table(as.factor(region))) %>% 
    prop.table %>% as.data.frame %>% mutate(region = Var1) %>% 
    mutate(wts = 1/Freq) %>% mutate(region = as.character(region))
  clusterobj$metadata <- clusterobj$metadata %>% left_join(wts %>% 
                                                             dplyr::select(region, wts), by = "region")
  head(clusterobj$metadata)
  if (do_harmony) {
    norm_value <- median(colSums(clusterobj$counts))
    objH <- QC_harmony_pipeline(clusterobj, ngenes_threshold = 1, 
                                ncounts_threshold = 1, norm_value, ...)
    objH$sigma_harmony <- sigma_harmony
    objH$vars_use <- batch_harmony
    objH$theta_harmony <- theta_harmony
    clusterobj <- objH
  }
  else {
    set.seed(9)
    # diag(clusterobj$umap$fgraph) <- 1
    print("Clustering on SNN")
    system.time({
      clusterobj$umap$clusters <- RunModularityClustering(clusterobj$umap$fgraph, 
                                                          resolution = c(0.2, 0.5, 0.7, 1), n_cores = 10, 
                                                          print.output = FALSE)
    })
  }
  return(clusterobj)
}







process_voronoi_data <- function(txfile, meta_list) {
  voronoi_obj_all <- list()  # Initialize empty list to store results
  
  for (i in 1:length(txfile)) {
    # Generate bounding box for Voronoi tessellation
    bbox_tx <- st_rectangle(min(txfile[[i]]$x), max(txfile[[i]]$x), min(txfile[[i]]$y), max(txfile[[i]]$y))
    message("Tessellating FOV ", i)
    
    # Generate Voronoi cells for each FOV based on cell centroids
    cells_voronoi <- pts_to_voronoi(meta_list[[i]]$cell_center_x, meta_list[[i]]$cell_center_y, bbox = bbox_tx)
    
    # Add cell IDs to Voronoi polygons
    cells_voronoi <- cells_voronoi %>% 
      as.data.frame() %>% 
      cbind(meta_list[[i]] %>% dplyr::select(cellID, cell_centroid, SampleFOV, SampleID)) %>% 
      dplyr::rename(polygon = geometry) %>% 
      dplyr::mutate(tileID = cellID)
    
    # Apply alpha shape to Voronoi cells
    cells_voronoi_alpha_shaped <- alpha_shape_cells(cells_voronoi)
    
    # Generate gene count matrix (gcmat) based on Voronoi polygons
    tfile_voronoi <- txfile[[i]][cell != 0] %>% 
      st_sf() %>% 
      st_join(
        cells_voronoi_alpha_shaped %>% 
          st_sf() %>% 
          st_set_geometry("polygon") %>% 
          dplyr::select(cellID, tileID, polygon),
        .predicate = st_intersects
      ) 
    
    # Remove tx (transcripts) not belonging to any cells
    tfile_voronoi <- data.table(tfile_voronoi)[!is.na(tileID)]
    
    # Generate gene count matrix (gcmat)
    gcmat_voronoi <- spatula::tx_to_counts(
      tfile_voronoi$gene, 
      tfile_voronoi$cellID, 
      remove_bg = TRUE
    )
    
    # Prepare Voronoi object with metadata and counts
    voronoi_obj <- list()
    voronoi_obj$metadata <- cells_voronoi_alpha_shaped %>% as.data.frame()
    voronoi_obj$counts <- gcmat_voronoi[, as.character(voronoi_obj$metadata$cellID)]
    
    # Add region information to the metadata
    voronoi_obj$metadata <- voronoi_obj$metadata %>% 
      dplyr::mutate(region = "tissue")
    
    # Store the Voronoi object in the results list
    voronoi_obj_all[[i]] <- voronoi_obj
  }
  
  return(voronoi_obj_all)  # Return the list of Voronoi objects
}







process_voronoi_and_glass <- function(voronoi_obj_all, txfile) {
  
  # Initialize lists for glass gridded data and cell geometries
  glass_gridded_ls <- list()
  cellgeoms_fov <- list()
  
  # Loop through each Voronoi object
  for (i in 1:length(voronoi_obj_all)) {
    obj <- voronoi_obj_all[[i]]
    tfile <- txfile[[i]]
    
    # Step 1: Define tissue and glass regions
    tissue_region <- obj$metadata %>% 
      st_sf() %>% 
      st_set_geometry("polygon") %>% 
      st_union() %>% 
      st_cast("MULTIPOLYGON") %>% 
      st_buffer(30)
    
    fov_region <- st_bbox(c(xmin = min(tfile$x), xmax = max(tfile$x), ymin = min(tfile$y), ymax = max(tfile$y))) %>% 
      st_as_sfc()
    
    glass_region <- st_difference(fov_region, tissue_region) %>% 
      as.data.frame() %>% 
      dplyr::mutate(region = "glass")
    
    # Check if glass region exists
    res <- !(spatstat.geom::is.empty(glass_region$geometry))
    obj$tissue_region <- tissue_region
    obj$glass_region <- glass_region
    obj$glass_exists <- res
    
    # Step 2: Gridding the glass region if it exists
    if (obj$glass_exists) {
      message("Gridding glass for sample ", i, ":")
      ncounts_glass <- IQR(colSums(obj$counts)) * 2.5
      glass_gridded_df <- grid_glass(
        glass_region_input = obj$glass_region, 
        txfile_input = tfile, 
        cellgeoms_input = obj$metadata, 
        by_counts = TRUE, 
        ncounts = ncounts_glass
      )
    } else {
      message("Not gridding glass: there is no glass beyond the buffered area for sample ", i)
      glass_gridded_df <- NULL
    }
    
    # Step 3: Process the glass gridded data if it's not null
    if (!is.null(glass_gridded_df)) {
      glass_gridded_df <- glass_gridded_df %>% 
        as.data.frame() %>% 
        dplyr::rename(polygon = geometry) %>% 
        dplyr::mutate(
          polygon_centroid = st_centroid(polygon),
          polygon_area = st_area(polygon),
          SampleID = obj$metadata[["SampleID"]] %>% unique(),
          SampleFOV = obj$metadata[["SampleFOV"]] %>% unique(),
          FOV = "FOV",
          region = "glass"
        )
      
      # Append to the glass gridded list
      glass_gridded_ls[[i]] <- glass_gridded_df
    }
    
    # Step 4: Combine the gridded glass data with the metadata for each sample
    metadata <- obj$metadata %>%
      dplyr::select(cellID, tileID, SampleFOV, SampleID, starts_with("polygon"), region)
    
    if (length(glass_gridded_ls) > 0) {
      cellgeoms_fov[[i]] <- bind_rows(metadata, glass_gridded_ls[[i]])
    } else {
      cellgeoms_fov[[i]] <- metadata
    }
  }
  
  # Return both the glass gridded list and the cell geometries list
  return(list(cellgeoms_fov = cellgeoms_fov, glass_gridded_ls = glass_gridded_ls))
}






process_voronoi_and_gcmat <- function(voronoi_obj_all, txfile, cellgeoms_fov, lambda = 0.03, k = 10) {
  res <- list()  # Initialize an empty list to store results
  
  # Loop over the Voronoi objects
  for (i in 1:length(voronoi_obj_all)) {
    message("Step 3: Build gcmat")
    
    # Remove background transcripts from tissue regions but not from glass
    txfile_tissue_glass <- txfile[[i]] %>%
      st_sf() %>%
      st_join(
        cellgeoms_fov[[i]] %>%
          st_set_geometry("polygon") %>%
          dplyr::select(cellID, tileID, polygon, region),
        .predicate = st_intersects
      ) %>%
      as.data.table()

    txfile_tissue_glass <- txfile_tissue_glass[!is.na(tileID)]
    txfile_tissue_glass <- txfile_tissue_glass[
      (cell != 0 & region == "tissue") | (region == "glass")
    ]
    
    # Build gcmat
    message("Building gcmat")
    gcmat_tissue_glass <- spatula::tx_to_counts(
      txfile_tissue_glass$gene,
      txfile_tissue_glass$tileID,
      remove_bg = FALSE
    )
    message("Done")
    
    # Set metadata for the current FOV
    fov1 <- list()
    fov1$metadata <- cellgeoms_fov[[i]] %>%
      subset(tileID %in% colnames(gcmat_tissue_glass)) %>%
      identity()
    
    # Skip processing if the number of rows in metadata is < 5
    if (nrow(fov1$metadata) < 5) {
      message("Skipping FOV ", i, " due to insufficient metadata rows (< 5).")
      next
    }
    
    # Process the sample if nrow >= 5
    fov1$counts_raw <- gcmat_tissue_glass[, as.character(fov1$metadata$tileID)]
    fov1$metadata <- fov1$metadata %>%
      dplyr::mutate(nCounts = colSums(fov1$counts_raw))
    fov1$metadata$FOV <- 'FOV'
    
    # Run diffusion-based adjacency matrix computation
    res[[i]] <- diffuse_adjmat(
      fov1$metadata, fov1$counts_raw,
      lambda = lambda, k = k, verbose = FALSE, cut_connections = TRUE,
      prune_connections = TRUE, prune_communities = TRUE,
      community_size_thresh = 4, pxsize = 1, dist_threshold_cells = 50
    )
  }
  
  # Clean up results: remove NULL and empty metadata entries
  names(res) <- names(cellgeoms_fov)
  res_f <- res[!sapply(res, is.null)]
  res_f2 <- res_f[!sapply(res_f, function(x) nrow(x$metadata) == 0)]
  
  # Update names of results with SampleFOV
  for (i in 1:length(res_f2)) {
    names(res_f2)[[i]] <- res_f2[[i]]$metadata$SampleFOV %>% unique()
  }
  
  return(res_f2)
}






process_voronoi_and_seurat <- function(res_f2, max_k = 10) {
  
  # Initialize lists to store results
  obj_list_k <- list()
  obj_list_k_seurat_counts <- list()
  seurats_k_merged <- list()
  obj_list_k_seurat_RAWcounts <- list()
  seurats_k_merged_raw <- list()
  meta_data_all_k_list <- list()
  obj_ksweep <- list()

  # Loop over the range of k (1 to max_k)
  for (k in 1:max_k) {
    
    # Step 1: Generate collapsed counts for each FOV (i)
    obj_final <- list()
    for (i in 1:length(res_f2)) {
      collapsed_counts <- res_f2[[i]]$counts_raw %*% t(res_f2[[i]]$neighbors_collapsed[[k]]) 
      colnames(collapsed_counts) <- colnames(res_f2[[i]]$counts_raw)
      
      # Store counts, metadata, and raw counts in the obj list
      obj <- list()
      obj$counts <- collapsed_counts
      obj$metadata <- res_f2[[i]]$metadata
      obj$counts_raw <- res_f2[[i]]$counts_raw
      
      obj_final[[i]] <- obj
    }
    
    # Add obj_final for each k to obj_list_k
    obj_list_k[[k]] <- obj_final
    
    # Step 2: Generate Seurat objects for collapsed counts
    obj_list_k_seurat_counts_tmp <- list()
    for (i in 1:length(res_f2)) {
      obj_list_k_seurat_counts_tmp[[i]] <- CreateSeuratObject(counts=obj_list_k[[k]][[i]]$counts)
    }
    obj_list_k_seurat_counts[[k]] <- obj_list_k_seurat_counts_tmp
    seurats_k_merged[[k]] <- merge(x = obj_list_k_seurat_counts[[k]][[1]], y = obj_list_k_seurat_counts[[k]][-1])
    
    # Step 3: Generate Seurat objects for raw counts
    obj_list_k_seurat_RAWcounts_tmp <- list()
    for (i in 1:length(res_f2)) {
      obj_list_k_seurat_RAWcounts_tmp[[i]] <- CreateSeuratObject(counts=obj_list_k[[k]][[i]]$counts_raw)
    }
    obj_list_k_seurat_RAWcounts[[k]] <- obj_list_k_seurat_RAWcounts_tmp
    seurats_k_merged_raw[[k]] <- merge(x = obj_list_k_seurat_RAWcounts[[k]][[1]], y = obj_list_k_seurat_RAWcounts[[k]][-1])
    
    # Step 4: Combine metadata for each k
    meta_data_all <- list()
    for (i in 1:length(res_f2)) {
      meta_data_all[[i]] <- obj_list_k[[k]][[i]]$metadata
      meta_data_all[[i]]$polygon <- NULL  # Remove the polygon column
    }
    meta_data_all <- rbindlist(meta_data_all, use.names = TRUE)
    meta_data_all_k_list[[k]] <- meta_data_all
  }

  # Step 5: Generate obj_ksweep with metadata and counts
  for (i in 1:length(meta_data_all_k_list)) {
    tmp_list <- list()
    tmp_list$metadata <- meta_data_all_k_list[[i]]
    tmp_list$counts <- seurats_k_merged[[i]]@assays[["RNA"]]@counts
    tmp_list$counts_raw <- seurats_k_merged_raw[[i]]@assays[["RNA"]]@counts
    obj_ksweep[[i]] <- tmp_list
  }
  
  # Return only obj_ksweep
  return(obj_ksweep)
}



